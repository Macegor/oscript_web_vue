// BSLLS:MagicNumber-off
#Использовать json
#Использовать strings

// Парсит тело запроса и по параметру приводит его к структуре 
//
// Параметры:
//   ЗапросHttp - ЗапросHttp
//   ПриводитьКСтруктуре - Булево - Если "Ложь" тогда тело вернется строкой, иначе структурой
//
//  Возвращаемое значение:
//   Структура, Строка - Тело запроса
//
Функция ПолучитьТелоЗапроса(ЗапросHttp, ПриводитьКСтруктуре = Истина) Экспорт

	ТипСодержимогоЗапроса = ЗапросHttp.Заголовки.Получить("Content-Type");

	// Обрабатываем чтение тела и результат записываем в данные запроса
	Если ТипСодержимогоЗапроса = "application/json" Тогда
		ПотокТелаЗапроса = ЗапросHttp.ПолучитьТелоКакПоток();
		ЧтениеДанных = Новый ЧтениеДанных(ПотокТелаЗапроса);
		ДДЗапроса = ЧтениеДанных.Прочитать().ПолучитьДвоичныеДанные();			
		ТелоЗапроса = ПолучитьСтрокуИзДвоичныхДанных(ДДЗапроса);
		ПарсерJSON = Новый ПарсерJSON();
		Если ЗначениеЗаполнено(ТелоЗапроса) Тогда
			ПолученныеДанные = ПарсерJSON.ПрочитатьJSON(ТелоЗапроса, Неопределено, Неопределено, ПриводитьКСтруктуре);	
		КонецЕсли;			
	КонецЕсли;	

	Возврат ПолученныеДанные;

КонецФункции

// Парсит параметры запроса и возвращает из в виде соответствия
//
// Параметры:
//   ЗапросHttp - ЗапросHttp
//
//  Возвращаемое значение:
//   Соответствие - Параметры запроса
//
Функция ПолучитьПараметрыЗапроса(ЗапросHttp) Экспорт

	Параметры = Новый Соответствие();
	СтрокаПараметровЗапроса = РаскодироватьСтроку(СтрЗаменить(ЗапросHttp.СтрокаЗапроса, "?", ""), СпособКодированияСтроки.URLВКодировкеURL);
	МассивПараметровСтрокой = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(СтрокаПараметровЗапроса, "&");

	Для каждого Элемент Из МассивПараметровСтрокой Цикл
		ДанныеПараметра = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(Элемент, "=");	
		Ключ = ДанныеПараметра[0];
		Значение = СокрЛП(ДанныеПараметра[1]);		
		Параметры.Вставить(Ключ, Значение);		
	КонецЦикла;	

	Возврат Параметры;

КонецФункции

// Формирует из возникшего исключения более читаемое описание ошибки и генерирует ответ на ЗапросHttp с кодом 500
//
// Параметры:
//   ИнформацияОбОшибке - ИнформацияОбОшибке
//
//  Возвращаемое значение:
//   РезультатДействияСодержимое - Подготовленный ответ на запрос с описанием ошибки
//
Функция ПодготовитьОшибку(ИнформацияОбОшибке) Экспорт

	ДанныеДляОтвета = Неопределено;
			
	ПараметрыОшибки = ИнформацияОбОшибке.Параметры;
	ТекстОшибки = ИнформацияОбОшибке.Описание;
	Если ТипЗнч(ПараметрыОшибки) = Тип("Массив") Тогда
		Для Каждого Ошибка Из ПараметрыОшибки Цикл
			ТекстОшибки = ТекстОшибки + Символы.ПС + Ошибка;
		КонецЦикла;
	КонецЕсли;	
	ДанныеДляОтвета = Новый Структура("error", ТекстОшибки);
				
	Возврат ПодготовитьОтвет(500, ДанныеДляОтвета);

КонецФункции

// Подготавливает ответ для запроса
//
// Параметры:
//   КодСостоянияОтвета - Число - Код состояния по соглашению
//   ДанныеДляСериализации - Структура, Массив, Неопределено - Сериализуемые в json данные
//   ТипСодержимого - Строка - Имя типа контента тела ответа по соглашению
//
//  Возвращаемое значение:
//   РезультатДействияСодержимое - Подготовленный класс для возврата на запрос
//
Функция ПодготовитьОтвет(КодСостоянияОтвета, ДанныеДляСериализации, ТипСодержимого = "application/json") Экспорт

	Ответ = Новый РезультатДействияСодержимое();
	Ответ.КодСостояния = КодСостоянияОтвета;
	Ответ.ТипСодержимого = ТипСодержимого;

	Если ЗначениеЗаполнено(ДанныеДляСериализации) Тогда
		Попытка
			ПарсерJSON = Новый ПарсерJSON();
			Ответ.Содержимое = ПарсерJSON.ЗаписатьJSON(ДанныеДляСериализации);
		Исключение
			Ответ.Содержимое = Новый Структура("error", ОписаниеОшибки());	
		КонецПопытки;		
	КонецЕсли;

	Возврат Ответ;

КонецФункции